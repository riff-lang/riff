// Intcode VM
// https://adventofcode.com/2019/day/2
// https://adventofcode.com/2019/day/5
// https://adventofcode.com/2019/day/9
//
// Provide program in the form of 9,1,204,-1,2205,-1,8,99,0 as the
// first argument
// Provide inputs in the form of 3,7,9 as the second argument

p = split($0, ",")
p = #p ? p : {9,1,204,-1,2205,-1,8,99,0}
inpv = split($1, ",")

verbose = 0
ascii   = 0

if ascii
    for i,v in inpv
        inpv[i] = char(inpv[i])

fn input {
    p[rx] = inpv[inpc++]
    ip += 2
}

fn output {
    if verbose
        outv[outc++] = ascii && x >=0 && x <= 127 ? char(x) : x
    else
        ascii && x >= 0 && x <= 127 ? char(x) : x
    ip += 2
}

fn flush_output {
    "--- BEGIN OUTPUT ---"
    for v in outv
        v
    "--- END OUTPUT ---"
}

// Opcodes
opcode = {
    null,
    fn { p[rz] = x + y  ip += 4 },   // add
    fn { p[rz] = x * y  ip += 4 },   // mul
    fn { input()                },   // in
    fn { output()               },   // out
    fn { ip =  x ? y :  ip +  3 },   // jt
    fn { ip = !x ? y :  ip +  3 },   // jf
    fn { p[rz] = x <  y ip += 4 },   // lt
    fn { p[rz] = x == y ip += 4 },   // eq
    fn { r += x         ip += 2 }    // rel
}

// halt
opcode[99] = fn {
    if verbose
        flush_output()
    exit
}

// Opcode mnemonics
m = { "nop", "add", "mul", "in", "out", "jt", "jf", "lt", "eq", "rel" }
m[99] = "halt"

fn rel_str(p,rb) {
    rb_op = p >= 0 ? "+" : ""
    return p == 0 ? "*"::rb : "*("::rb::rb_op::p::")"
}

disas = {
    null,
    fn { ip, "\t", zm,  ym, xm, m[op], "\t", px, py, pz },
    fn { ip, "\t", zm,  ym, xm, m[op], "\t", px, py, pz },
    fn { ip, "\t", "   ",   xm, m[op], "\t", px },
    fn { ip, "\t", "   ",   xm, m[op], "\t", px },
    fn { ip, "\t", " ", ym, xm, m[op], "\t", px, py },
    fn { ip, "\t", " ", ym, xm, m[op], "\t", px, py },
    fn { ip, "\t", zm,  ym, xm, m[op], "\t", px, py, pz },
    fn { ip, "\t", zm,  ym, xm, m[op], "\t", px, py, pz },
    fn { ip, "\t", "   ",   xm, m[op], "\t", px }
}

disas[99] = fn {
    ip, "\t", "     ", m[op]
    "halted successfully"
    "instruction count:", count
}

ip = 0
while 1 {
    op  = p[ip]
    xm  = op / 100   % 10 | 0
    ym  = op / 1000  % 10 | 0
    zm  = op / 10000 % 10 | 0
    op %= 100
    x   = xm == 1 ? p[ip+1]
        : xm == 2 ? p[p[ip+1]+r]
        : p[p[ip+1]]
    y   = ym == 1 ? p[ip+2]
        : ym == 2 ? p[p[ip+2]+r]
        : p[p[ip+2]]
    rx  = xm ? p[ip+1]+r : p[ip+1]
    rz  = zm ? p[ip+3]+r : p[ip+3]
    p[rz] = p[rz] ?: 0
    if verbose {
        px = xm == 1 ? p[ip+1]
           : xm == 2 ? rel_str(p[ip+1], r)::"->"::x
           : "*"::p[ip+1]::"->"::x
        py = ym == 1 ? p[ip+2]
           : ym == 2 ? rel_str(p[ip+2], r)::"->"::y
           : "*"::p[ip+2]::"->"::y
        pz = zm ? rel_str(p[ip+3], r)::"->"::p[rz]
           : "*"::p[ip+3]::"->"::p[rz]
        disas[op]()
    }
    opcode[op]()
    count++
    ip = ip ?: 0
}
